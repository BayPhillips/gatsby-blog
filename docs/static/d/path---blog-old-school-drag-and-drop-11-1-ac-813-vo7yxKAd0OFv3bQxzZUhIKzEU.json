{"data":{"contentfulBlogPost":{"id":"97de17f2-aded-546b-8ee2-22e128be71ab","postTitle":"Old School Drag and Drop11","postContent":{"childMarkdownRemark":{"html":"<h2>Protocol extensions in Swift 2.0 rule</h2>\n<p>One of the features I was most excited about when Swift 2.0 was announced was the ability to provide an extension for a protocol. This means that you can provide a default implementation for an object that adheres to a protocol. Think of this like a ruby mixin!</p>\n<h2>A real world example</h2>\n<p>What does this look like? Let's start with something simple: we want to provide a common protocol to make things draggable.  We'll define the Draggable protocol to have the following:</p>\n<pre><code>protocol Draggable: class {\n  var view: UIView { get }\n  var initialLocation: CGPoint { get set }\n\n  func registerDraggability() -> Void\n  func removeDraggability() -> Void\n  func didPress(pressGesture: UILongPressGestureRecognizer) -> Void\n  func didPan(panGesture: UIPanGestureRecognizer) -> Void\n}\n</code></pre>\n<ul>\n<li>view is is the actual UIView we want to move</li>\n<li>initialLocation is the starting center when dragging</li>\n<li>registerDraggability() is called when we want our class to start listening to dragging</li>\n<li>removeDraggability() is the opposite, where say we no longer want our class  to be draggable anymore</li>\n<li>didPress and didPan are the two functions to handle the actual pressing and panning</li>\n</ul>\n<p>Normally, this would be pretty straight forward: You would create a UIView subclass that would adopt the Draggable protocol to which you'd then implement the necessary properties and functions.</p>\n<p>This works great until you need to do this for another subview. So then you repeat: subclass, adopt and implement. All of the sudden, you're writing what's basically the same code over and over. That's bad! As engineers, we want to write code that's DRY (don't repeat yourself) so whats our first take at rectifying this?</p>\n<h2>Composition vs. Inheritance</h2>\n<p>If your first response was to create a baseclass that adopts and implements the Draggable protocol, you wouldn't be wrong and infact that's a perfectly sensible approach.</p>\n<p>Inheritance is a powerful and a tried and true programming practice that has its place; however, it is possible to get into hierarchy hell. I know I've run into the issue of having too many UI classes that inherit from each other and making one small change in a base class ends up affecting WAY too many of its descendants.</p>\n<p>This is where composition shines!</p>\n<p>Instead of having a long chain of subclasses that can be somewhat brittle, we'd like to compose our objects to adhere to our various protocols. This becomes very viable with protocol extensions as we now can provide a default implementation of a protocol:</p>\n<pre><code>extension Draggable where Self: UIView {\n  \n}\n</code></pre>\n<p>The real beauty of this protocol extension is we're giving ourselves access to any UIView that adopts the Draggable protocol! How awesome is that? For example, you remember that view property in the Draggable protocol that is required to be implemented? Now we can just do this:</p>\n<pre><code>extension Draggable where Self: UIView {\n  var view: UIView { get { return self } }\n  var parentView: UIView? { get { return self.view.superview } }\n}\n</code></pre>\n<p>Basically, any UIView that has the Draggable protocol automatically receives the built in functionality. So what about the remainder of the protocol's definition? Let's fill them out:</p>\n<pre><code>func registerDraggability() {\n  let panGesture = UIPanGestureRecognizer()\n  panGesture.handler = { gesture in\n  self.didPan(gesture as! UIPanGestureRecognizer)\n}  \n\nself.view.addGestureRecognizer(panGesture)\n\nlet pressGesture = UILongPressGestureRecognizer()\npressGesture.minimumPressDuration = 0.001\npressGesture.handler = { gesture in\n  self.didPress(gesture as! UILongPressGestureRecognizer)\n}\n\nself.view.addGestureRecognizer(pressGesture)\n}\n\nfunc removeDraggability() {\n  guard self.gestureRecognizers != nil else {\n  return\n}\n\nlet _ = self.gestureRecognizers!\n  .filter({ $0.delegate is UIGestureRecognizer.GestureDelegate })\n  .map({ self.removeGestureRecognizer($0) })\n}\n\nfunc didPress(pressGesture: UILongPressGestureRecognizer) {\n  switch pressGesture.state {\n  case UIGestureRecognizerState.Began:\n    self.initialLocation = self.view.center\n    UIView.animateWithDuration(0.1, animations: { () -> Void in\n      self.parentView?.bringSubviewToFront(self.view)\n      self.view.transform = CGAffineTransformMakeScale(0.80, 0.80)\n    })\nbreak\ncase UIGestureRecognizerState.Cancelled, UIGestureRecognizerState.Ended, UIGestureRecognizerState.Failed:\n  UIView.animateWithDuration(0.1, animations: { () -> Void in\n    self.view.transform = CGAffineTransformMakeScale(1.0, 1.0)\n  })\nbreak\ndefault:\nbreak\n}\n}\n\nfunc didPan(panGesture: UIPanGestureRecognizer) {\n  let translation = panGesture.translationInView(self.parentView)\n  self.view.center = CGPointMake(self.initialLocation.x + translation.x,       self.initialLocation.y + translation.y)\n}\n</code></pre>\n<p>I don't believe I need to go over the code to drag a UIView as that's been covered dozens of times, but there are some caveats that I'd like to bring up:</p>\n<p>I had to extend the UIGestureRecognizer class in order to add a method called handler. Tyler Tillage over at CapTech did an excellent job explaining why I couldn't just use the existing addTarget: action: in the protocol extension here. Long story short:</p>\n<p>UIKit is still compiled from Objective-C, and Objective-C has no concept of protocol extendability. What this means in practice is that despite our ability to declare extensions on UIKit protocols, UIKit objects can't see the methods inside our extensions.</p>\n<p>To get around this, my handler closure wraps around some object associations to store the closure which is then called on a default selector. I'll write another post about why I had to do all of this, but feel free to check out this extension.</p>\n<p>Just tell me what I need to do to make things draggable!</p>\n<p>When all is said and done, we want it to be as easy as pie to make ANY UIView draggable. I feel like I'm almost there with this:</p>\n<pre><code>class DraggableView: UIView, Draggable\n{\n  var initialLocation: CGPoint = CGPointZero\n\n  override func didMoveToSuperview() {\n    if self.superview != nil {\n      self.registerDraggability()\n    } else {\n      self.removeDraggability()\n    }\n  }\n}\n</code></pre>\n<p>All you need to do is register the draggability on the view, and provide a storage backing for the view's initial location before it starts dragging. Pretty simple right?</p>\n<p>The best part of this is it can now be applied to other, UIView backed classes! How about UICollectionViewCell?</p>\n<pre><code>class DraggableCell: UICollectionViewCell, Draggable {\n\n  var initialLocation: CGPoint = CGPointZero\n\n  override func didMoveToSuperview() {\n    if self.superview != nil {\n        self.registerDraggability()\n    } else {\n        self.removeDraggability()\n    }\n  }\n}\n</code></pre>\n<p>Remember, we're not creating a single DraggableView baseclass that requires all of our other classes to subclass. We're simply adding the additional functionality provided by the protocol and its default extension.</p>\n<p>Closing thoughts...</p>\n<p>I don't think I'm sold on this implementation yet. I'm not a fan of object association as some of it feels dirty but in the end it does work, pretty well at that too. The biggest limitation right now is that extensions cannot store additional values and they do not support really anything regarding selectors. Once those two features are put in place, we'll really be able to do some even more amazing things without having to jump through loops.</p>\n<p>Feel free to check out the repository on GitHub and let me know what you think! I'd love to clean this up more if anyone has better ideas!</p>"}},"datePosted":"2017-09-28","author":{"name":"Bay Phillips"},"postSlug":"old-school-drag-and-drop11","contentPreview":{"childMarkdownRemark":{"html":"<p>Before iOS 11, Drag and Drop wasn't just a given. I wrote this as a fun way to play around with new features of Swift 2.0.</p>"}}}},"pageContext":{"jsonName":"blog-old-school-drag-and-drop-11-1ac","internalComponentName":"ComponentBlogOldSchoolDragAndDrop11","path":"/blog/old-school-drag-and-drop11/","component":"/home/circleci/workspace/src/templates/blogPost.js","componentChunkName":"component---src-templates-blog-post-js","context":{"postSlug":"old-school-drag-and-drop11"},"updatedAt":1529787397723,"pluginCreator___NODE":"Plugin default-site-plugin","pluginCreatorId":"Plugin default-site-plugin","componentPath":"/home/circleci/workspace/src/templates/blogPost.js","postSlug":"old-school-drag-and-drop11"}}